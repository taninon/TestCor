# TestCor
コルーチンの説明用

講義用のリポジトリです。

## コルーチンとは何か

命令を逐次的に実行することができる。

Unityの独自機能として、

・任意の時間を待つ
・条件が整うまで待つ
・1フレームづつ実行する

などのことができる。

## 任意の時間を待つ なにが嬉しいのか？

テストシーン CorTest.unity
1秒ごとにインスタンシエイトする。

　ゲームの場合、演出を待ったり、逆に実行を少し遅らせたいときがちょくちょくある。

例えば……
　ダメージエフェクトが終わったあとに処理をすすめたい
　ボタンを押して少し待ってから扉を開けたい

　「ちょっとだけ時間軸を制御したい」というときUpdateに書くとずーっと監視することになってしまったり、Update内が膨れてカオスになったりする。

　コルーチンで実装すれば単純化できる。


## 条件が整うまで待つ なにが嬉しいのか？

一直線で戻ることのない（シーケンシャルという）処理を簡単に書ける。
秒数ではなく「なにかが終了するまで待つ」ということができる。
アニメーション終了、ダウンロード、API通信終了など。

これらをイベントやコールバックだけで実装すると非常に複雑になることがある。

テストシーン CorButton.unity
ボタンを押すごとにスフィアを作成する。


## 1フレームづつ実行する なにが嬉しいのか？

　非同期処理ライクな処理とパフォーマンスの向上が行える
　Unityでは同一フレームで重い処理を同時に行うと画面がカクつきます。
  例えば先ほどのInstantiateが重い処理の一つです。
  
  PCでは問題にならないことも多いですが、スマートフォンなどでは問題になります
 
　テストシーン CorMakeSphere.unity
  回転させながら実行する。
 
  コルーチンで非同期っぽいフレームレートを維持した処理が書ける。
　1フレームごとに分けるやり方でシンプル。
　演出とセットで考えるといい。
 
　ロード画面でカクつく現象を（これと非同期ローディング等を組み合わせることで）低減させることができます。



## コルーチンの落とし穴

　便利なコルーチンですが、注意して使わないとバグの温床になります。

### 攻撃を受けて何秒か後に消えるという処理があったとして、その間に何度もダメージを受けたりしたら？
　複数回処理実行の可能性を考慮しないとバグるかも。

### コルーチンで指定する先の未来で状態が維持されているとは限らない
　エフェクト終了後に処理をしようとしたら、すでに存在しないというようなことがありえます。

### コルーチンはゲームオブジェクトがオフになった時に止まる（復帰しない）
　階層構造になっているUIなどの場合、上のゲームオブジェクトがOFFになってしまうと止まってしまい、重要な処理が実行されないとか。
 
## これらの特性を踏まえた上で扱い方

### コルーチンはなるべく「演出」「見た目」などに使う。
実際の内部処理（たとえばパラメーターの増減）は同期でやった方が無難。

### コルーチンで行う重要な処理は一つにまとめる
重要な処理を伴うものをいろんなコンポーネントから行うようにしてしまうと、バグったときに追いにくくなったりします。
コンポーネントごとにばらばらのループを持てるのがMonoBehaviourの特徴と利点の一つですが、あまり多用すると実行時にどこでバグるのか分かりにくいコードになりがちです。
 
